// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sgin_in_state.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Text Editing Controller Providers with proper disposal

@ProviderFor(FirstNameController)
const firstNameControllerProvider = FirstNameControllerProvider._();

/// Text Editing Controller Providers with proper disposal
final class FirstNameControllerProvider
    extends $NotifierProvider<FirstNameController, TextEditingController> {
  /// Text Editing Controller Providers with proper disposal
  const FirstNameControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'firstNameControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$firstNameControllerHash();

  @$internal
  @override
  FirstNameController create() => FirstNameController();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TextEditingController value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TextEditingController>(value),
    );
  }
}

String _$firstNameControllerHash() =>
    r'233c527d9ae3d443ae531335cffed6d164b587bf';

/// Text Editing Controller Providers with proper disposal

abstract class _$FirstNameController extends $Notifier<TextEditingController> {
  TextEditingController build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<TextEditingController, TextEditingController>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<TextEditingController, TextEditingController>,
              TextEditingController,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(PassController)
const passControllerProvider = PassControllerProvider._();

final class PassControllerProvider
    extends $NotifierProvider<PassController, TextEditingController> {
  const PassControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'passControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$passControllerHash();

  @$internal
  @override
  PassController create() => PassController();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TextEditingController value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TextEditingController>(value),
    );
  }
}

String _$passControllerHash() => r'6ce9cb4d8f98483ea56ea95dabcddb103981c66b';

abstract class _$PassController extends $Notifier<TextEditingController> {
  TextEditingController build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<TextEditingController, TextEditingController>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<TextEditingController, TextEditingController>,
              TextEditingController,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(EmailController)
const emailControllerProvider = EmailControllerProvider._();

final class EmailControllerProvider
    extends $NotifierProvider<EmailController, TextEditingController> {
  const EmailControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'emailControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$emailControllerHash();

  @$internal
  @override
  EmailController create() => EmailController();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TextEditingController value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TextEditingController>(value),
    );
  }
}

String _$emailControllerHash() => r'27b97914ccd7d4b0d8797ddde889cc916bc96401';

abstract class _$EmailController extends $Notifier<TextEditingController> {
  TextEditingController build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<TextEditingController, TextEditingController>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<TextEditingController, TextEditingController>,
              TextEditingController,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(AgeController)
const ageControllerProvider = AgeControllerProvider._();

final class AgeControllerProvider
    extends $NotifierProvider<AgeController, TextEditingController> {
  const AgeControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'ageControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$ageControllerHash();

  @$internal
  @override
  AgeController create() => AgeController();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TextEditingController value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TextEditingController>(value),
    );
  }
}

String _$ageControllerHash() => r'9566eeec2224f600288465067d437b587498370a';

abstract class _$AgeController extends $Notifier<TextEditingController> {
  TextEditingController build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<TextEditingController, TextEditingController>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<TextEditingController, TextEditingController>,
              TextEditingController,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(PhoneNumberController)
const phoneNumberControllerProvider = PhoneNumberControllerProvider._();

final class PhoneNumberControllerProvider
    extends $NotifierProvider<PhoneNumberController, TextEditingController> {
  const PhoneNumberControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'phoneNumberControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$phoneNumberControllerHash();

  @$internal
  @override
  PhoneNumberController create() => PhoneNumberController();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TextEditingController value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TextEditingController>(value),
    );
  }
}

String _$phoneNumberControllerHash() =>
    r'85a5ed3cd8d0c6d97d36ae5c2d37519a62ab821b';

abstract class _$PhoneNumberController
    extends $Notifier<TextEditingController> {
  TextEditingController build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<TextEditingController, TextEditingController>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<TextEditingController, TextEditingController>,
              TextEditingController,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Sign In State Notifier - Fixed version

@ProviderFor(SignInNotifier)
const signInProvider = SignInNotifierProvider._();

/// Sign In State Notifier - Fixed version
final class SignInNotifierProvider
    extends $NotifierProvider<SignInNotifier, AsyncValue<User>> {
  /// Sign In State Notifier - Fixed version
  const SignInNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'signInProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$signInNotifierHash();

  @$internal
  @override
  SignInNotifier create() => SignInNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AsyncValue<User> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AsyncValue<User>>(value),
    );
  }
}

String _$signInNotifierHash() => r'170debbebfb3405a78c4a87cb560f435c28effe9';

/// Sign In State Notifier - Fixed version

abstract class _$SignInNotifier extends $Notifier<AsyncValue<User>> {
  AsyncValue<User> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<User>, AsyncValue<User>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<User>, AsyncValue<User>>,
              AsyncValue<User>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Login State Notifier - Fixed version

@ProviderFor(LoginNotifier)
const loginProvider = LoginNotifierProvider._();

/// Login State Notifier - Fixed version
final class LoginNotifierProvider
    extends $NotifierProvider<LoginNotifier, AsyncValue<User>> {
  /// Login State Notifier - Fixed version
  const LoginNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'loginProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$loginNotifierHash();

  @$internal
  @override
  LoginNotifier create() => LoginNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AsyncValue<User> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AsyncValue<User>>(value),
    );
  }
}

String _$loginNotifierHash() => r'6f9f95ca9570cc7ea1b4355b0f0c452e4b34a667';

/// Login State Notifier - Fixed version

abstract class _$LoginNotifier extends $Notifier<AsyncValue<User>> {
  AsyncValue<User> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<User>, AsyncValue<User>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<User>, AsyncValue<User>>,
              AsyncValue<User>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Get User State Notifier - Fixed version

@ProviderFor(GetUserNotifier)
const getUserProvider = GetUserNotifierProvider._();

/// Get User State Notifier - Fixed version
final class GetUserNotifierProvider
    extends $NotifierProvider<GetUserNotifier, AsyncValue<User>> {
  /// Get User State Notifier - Fixed version
  const GetUserNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getUserProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getUserNotifierHash();

  @$internal
  @override
  GetUserNotifier create() => GetUserNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AsyncValue<User> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AsyncValue<User>>(value),
    );
  }
}

String _$getUserNotifierHash() => r'551ace6f970e9c58b0ccaab8b20e1b1c0cb7242f';

/// Get User State Notifier - Fixed version

abstract class _$GetUserNotifier extends $Notifier<AsyncValue<User>> {
  AsyncValue<User> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<User>, AsyncValue<User>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<User>, AsyncValue<User>>,
              AsyncValue<User>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Sign Out User State Notifier - Fixed version

@ProviderFor(SignOutNotifier)
const signOutProvider = SignOutNotifierProvider._();

/// Sign Out User State Notifier - Fixed version
final class SignOutNotifierProvider
    extends $NotifierProvider<SignOutNotifier, AsyncValue<bool>> {
  /// Sign Out User State Notifier - Fixed version
  const SignOutNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'signOutProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$signOutNotifierHash();

  @$internal
  @override
  SignOutNotifier create() => SignOutNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AsyncValue<bool> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AsyncValue<bool>>(value),
    );
  }
}

String _$signOutNotifierHash() => r'6f011a90fda46a288583a4a6b44fdf53d8c041f4';

/// Sign Out User State Notifier - Fixed version

abstract class _$SignOutNotifier extends $Notifier<AsyncValue<bool>> {
  AsyncValue<bool> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<bool>, AsyncValue<bool>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<bool>, AsyncValue<bool>>,
              AsyncValue<bool>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
